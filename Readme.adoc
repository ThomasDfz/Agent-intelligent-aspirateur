= TP IA 1

:toc:
:authors: Thomas Defossez  Edouard François 

== Introduction

Ce TP est réalisé dans le cadre du cours d'IA de l'UQAC.
Il a pour but de modéliser un agent simple ayant pour but d'aspirer la 
poussière et ramasser les bijoux tombés sur le sol, le tout avec une efficacité 
maximale. +
Pour présenter ce TP que nous avons réalisé en C\#, nous étudierons trois aspects :
[circle]
* L'environement
* L'agent
* L'affichage

== L'environnement

=== Caractéristiques

L'environnement possède les propriétés suivantes :

[circle]
* Complétement observable, car les capteurs de l'agent peuvent voir toutes les 
pièces du manoir.
* Stochastique, car l'aléatoire joue un rôle dans l'apparition des objets.
* Séquentiel car un épisode dépend du précédent notamment dans la position de l'agent
* Dynamique, en effet une poussière ou un bijou peut apparaître alors que l'agent
est en pleine délibération
* Discret car il existe un nombre fini d'états.
* Enfin c'est un environnement ne disposant que d'un agent.

=== Notre implémentation

L'environnement est constitué d'un damier rectangulaire, de dimentions x et y 
pouvant être changés. Il consiste en un tableau à 2 dimensions de _Room_, 
classe créée pour représenter chaque pièce, pouvant contenir de la poussière,
un bijou, les deux ou aucun des deux.

L'environnement va, dans un fil d'éxécution différent de l'agent et de 
l'affichage, sporadiquement générer de la poussière ou un bijou (_GenerateDirtOrJewel()_)
dans une des cases selon des probabilités que nous fixons.
Si une poussière doit être générée dans une pièce en contenant déjà, on ne 
cherche pas à trouver une nouvelle pièce propre, en effet la présence de poussière 
étant modélisée par un booléen, la pièce est simplement plus sale qu'avant mais 
un seul coup d'aspirateur en viendra à bout. De même pour les bijoux.
L'environnement va être informé des actions de l'agent et pourra ainsi mettre à 
jour le contenu de ses pièces ainsi qu'informer la vue de se rafraîchir. (_ExecuteAgentAction()_)

L'environnement détient aussi la mesure de performance de l'agent. Elle est liée
à l'électricité utilisée par l'agent (-1 par action : mouvement, ramasser un bijou, 
aspirer) et un certain nombre de points est ajouté à cette mesure de performance 
basé sur la taille de l'environnement (pour pouvoir être équitable si 
l'environnement est grand). Si l'agent aspire un bijou, la mesure de performance 
baisse de 5 fois ce nombre de points. Elle est consultable en tout temps par l'agent.

== L'agent basé sur les buts

=== Modélisation des caractéristiques de l'agent

==== Capteurs/Effecteurs

Ici les capteurs ont été modélisés par de simples entiers permettant d'itérer à
travers les salles de l'environnement afin d'en extraire les données ou permettant
de récupérer la mesure de performane.

Ses effecteurs ont été implémentés sous forme d'énumération (_Effectors.cs_).
Ils sont au nombre de 6 : MoveUp, MoveDown, MoveLeft, MoveRight, Vacuum, PickUpJewel.
Nous avons en effet considéré chacun des 4 mouvements comme induits par un effecteur différent.

==== Belief/Desire/Intention

Conformément au cours, nous avons implémenté pour notre agent un modèle
beliefs/desire/intention. Nous nous sommes penchés sur l'implémentation la plus logique
et les avons définit comme suit :

[circle]
* Les croyances (attribut privé _\_beliefs_ de la classe Agent) sont une classe à part
entière (_Beliefs.cs_). Elle contient une réplique du manoir, implémentée de la même
façon, c'est à dire un tableau de _Room_ nommé _\_believedRooms_ et modifié lorsque l'agent
met à jour son état interne.
* Les désirs sont ici modélisés par un _Vertex_ (classe implémentée dans _Graph.cs_ représentant
un noeud). En effet, lorsque l'agent a repéré l'objet le plus proche, son désire est de
se rendre dans la pièce correspondante pour intéragir avec.
* Les intentions ont été implémentées sur la forme d'une pile d'_Effectors_. Le résultat 
des algorithmes de plus court chemin ainsi que les croyances sur la pièce désirée 
vont permettre de remplir cette pile d'intentions qu'il suffira ensuite de dépiler.

==== Cycle de vie

=== Recherche du plus court chemin

== L'affichage

NOTE: Les images de la grille étant affichées en tant que background, nous ne 
pouvions qu'afficher une image à la fois par case, c'est ainsi que si l'agent 
passe sur une case déjà occupée par de la poussière ou un bijoux, ces images vont 
disparaître (et réaparaître lorsque l'agent change de case) sans obligatoirement
que l'agent les aient aspiré ou ramassé. +
Pour être certain que lorsque l'agent passe sur une case contenant les deux 
objets il ai bien ramassé les bijoux puis aspiré la poussière, il faut regarder
les messages de la console.